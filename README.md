# grapeDB
> 这个版本，相对于上一个版本而言, 用特定的方式写入/读出磁盘, 实现了对数据的持久化. 但同时, 为了方便, 我并没有单独实现将数据存储在磁盘上, 只在内存中存放index的目标, 而是在初始化时就把所有数据统统读取到内存, 然后在关闭连接时全部持久化到磁盘中, 这样实现对于大型数据库来说可能是不好的, 但是对于微型数据库来说, 当前的电脑内存存放这么一些数据并不会有什么压力才对.

> 上一个版本实现了对SQL命令的解析，不再像上一个版本一样局限于单条件主键的查询。 从此除了还未能写到磁盘上，其余的已经是一个满足了数据库基本要求的项目了。并且我在其中支持了对jdbc的几个接口实现。

## 从零开始写数据库
> Version 0.3, 出于学习的目的, 我想要实现一个数据库, 目标很低, 只打算实现一个内存数据库, 支持create table, create index, select/delete/update只需要支持单条件, 支持insert, 算是满足数据库能力的最低配版本

## 1.从内存数据库开始
> 毫无疑问, 内存数据库最简单的实现形式就是一个parser解析器搭配hashmap, 每个table对应一个hashmap, primary key对应map的key,
> 然而当数据较少时, 比如一万以下, 十万以下, 还有可能使用hashmap, 当在实际商业使用中, 千万上亿级别的数
> 据量对于需要相当的空间冗余的hashmap来说就变得无法忍受, 因此对于关系型数据库, B+树是目前来说的不二选择
 
## B+树
B+树是应文件系统所需而出的一种B-树的变型树。一棵m阶的B+树和m阶的B-树的差异在于：
1.有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。
2.所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
3.所有的非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大（或最小）关键字。

### Value类及其子类 -- 最底层的数据类型
就像int和Integer的关系一样, 我们希望将一个值的方法做一些定制, 作为函数实现函数的依据, 希望指定数据库中的值类型让它不是一个Object因此我们创建了Value类及其子类

### Table 包
1. column 类 -- 定义一个列的数据类型
2. table 类 -- 定义一个表的数据类型
3. Row 类 -- 存放一组数据

### index 包
思想是这样的--每个table由1个到多个index组成, 每个index表示一组B+树, 必须是unique的列才能建立index, 默认情况下使用primarykey作为index建立一棵index树
当我们搜索时, 首先查找要搜索的where条件式对应的条件是否已经有对应的index,如果有,则使用对应的index, 否则遍历查找

### parser 包
parser包的作用在于将sql语句解析出来, 并针对调用查找

## END
> 我所发布的数据都会经过简单测试, 但不能保证在所有场景下都能完全正确运行. 
