# grapeDB

## 从零开始写数据库
> Version 0.3, 出于学习的目的, 我想要实现一个数据库, 目标很低, 只打算实现一个内存数据库, 支持create table, create index, select/delete/update只需要支持单条件, 支持insert, 算是满足数据库能力的最低配版本

## 1.从内存数据库开始
> 毫无疑问, 内存数据库最简单的实现形式就是一个parser解析器搭配hashmap, 每个table对应一个hashmap, primary key对应map的key,
> 然而当数据较少时, 比如一万以下, 十万以下, 还有可能使用hashmap, 当在实际商业使用中, 千万上亿级别的数
> 据量对于需要相当的空间冗余的hashmap来说就变得无法忍受, 因此对于关系型数据库, B+树是目前来说的不二选择
 
## B+树
B+树是应文件系统所需而出的一种B-树的变型树。一棵m阶的B+树和m阶的B-树的差异在于：
1.有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。
2.所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
3.所有的非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大（或最小）关键字。

### Value类及其子类 -- 最底层的数据类型
就像int和Integer的关系一样, 我们希望将一个值的方法做一些定制, 作为函数实现函数的依据, 希望指定数据库中的值类型让它不是一个Object因此我们创建了Value类及其子类

### Table 包
1. column 类 -- 定义一个列的数据类型
2. table 类 -- 定义一个表的数据类型
3. Row 类 -- 存放一组数据

### index 包
思想是这样的--每个table由1个到多个index组成, 每个index表示一组B+树, 必须是unique的列才能建立index, 默认情况下使用primarykey作为index建立一棵index树
当我们搜索时, 首先查找要搜索的where条件式对应的条件是否已经有对应的index,如果有,则使用对应的index, 否则遍历查找

### parser 包
parser包的作用在于将sql语句解析出来, 并针对调用查找


